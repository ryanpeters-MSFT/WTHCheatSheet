# Challenge 04 - Your First Deployment


```powershell
# MAKE SURE THEY AUTHENTICATE TO THEIR CLUSTER!!
az aks get-credentials -n wthcluster -g rg-wth --overwrite-existing

# deploy the (modified) API deployment yaml
kubectl apply -f .\api-deployment.yaml

# shell into the container/pod
kubectl get pods
kubectl exec -it PODNAME -- bash

# curl the localhost app and get speakers JSOM
curl http://localhost:3001/speakers

# deploy the service for the api
# NOTE: can be quickly/temporarily verified by changing the service spec.type to be "LoadBalancer" and curl to the the public IP
kubectl apply -f .\api-service.yaml

# deploy the web app and service
kubectl apply -f .\web-deployment.yaml -f .\web-service.yaml

# list the services to find the one we want
kubectl get svc

# or more specifically...
kubectl get svc web --output jsonpath="{.status.loadBalancer.ingress[0].ip}"
```

## Tips
- Users can quickly test their API service by changing the `spec.type` property of their service to be `LoadBalancer` and wait for a public IP
- The YAML for any resource can be generated by specifying the `-o yaml` argument on a `kubectl get RESOURCE` command. For example, `kubectl get pod api-66f497b499-z5dnr -o yaml` will yield the full/detailed YAML for that pod resource.
- Some YAML files can be quickly generated using commands, instead of piecing together a YAML file from scratch (removing everything after `--dry-run` will create the resource without outputting a YAML):
```powershell
# quick deploy YAML creation
kubectl create deploy nginx --replicas 2 --image=nginx --dry-run=client -o yaml > deployment.yaml

# quick service creation by "exposing" a deployment (or pod, or ds, etc) as a service
kubectl expose deploy web --type LoadBalancer --port 80 --name "web-svc" --dry-run=client -o yaml > service.yaml
```