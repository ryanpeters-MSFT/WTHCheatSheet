# Challenge 04 - Your First Deployment


```powershell
# MAKE SURE THEY AUTHENTICATE TO THEIR CLUSTER!!
az aks get-credentials -n wthcluster -g rg-wth --overwrite-existing

# deploy the (modified) API deployment yaml
kubectl apply -f .\api-deployment.yaml

# get pod name and shell into the container/pod
kubectl get pods
kubectl exec -it PODNAME -- bash

# once on the pod shell, curl the API at localhost and get speakers JSON
curl http://localhost:3001/speakers

# deploy the service for the api
kubectl apply -f .\api-service.yaml
```

**Make sure users set the `CONTENT_API_URL` environment variable in their web deployment to the name of the API service name.**

```powershell
# deploy the web app and service
kubectl apply -f .\web-deployment.yaml -f .\web-service.yaml
```

Once deployed, get the service's external IP and open in the browser.

```powershell
# list the services to find the one we want
kubectl get svc

# or more specifically...
kubectl get svc web --output jsonpath="{.status.loadBalancer.ingress[0].ip}"
```

## Tips
- Users can optionally test their API service by changing the `spec.type` property of their service to be `LoadBalancer` test the API using the public/external IP.
- The YAML for any resource can be generated by specifying the `-o yaml` argument on a `kubectl get RESOURCE` command. For example, `kubectl get pod api-66f497b499-z5dnr -o yaml` will yield the full/detailed YAML for that pod resource.
- Some YAML files can be quickly generated using commands, instead of piecing together a YAML file from scratch (removing everything after `--dry-run` will create the resource without outputting a YAML):
```powershell
# quick deploy YAML creation
kubectl create deploy nginx --replicas 2 --image=nginx --dry-run=client -o yaml > deployment.yaml

# quick service creation by "exposing" a deployment (or pod, or ds, etc) as a service
kubectl expose deploy web --type LoadBalancer --port 80 --name "web-svc" --dry-run=client -o yaml > service.yaml
```